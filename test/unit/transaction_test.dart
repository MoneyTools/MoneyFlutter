import 'package:flutter_test/flutter_test.dart';
import 'package:money/data/models/money_objects/accounts/account.dart';
import 'package:money/data/models/money_objects/transactions/transaction.dart';
import 'package:money/data/storage/data/data.dart'; // For Data singleton
import 'package:money/data/models/money_objects/payees/payees.dart';
import 'package:money/data/models/money_objects/categories/categories.dart';
import 'package:money/data/models/money_objects/aliases/aliases.dart';
import 'package:money/data/models/money_objects/currencies/currencies.dart';
import 'package:money/data/models/money_objects/investments/investments.dart';
import 'package:money/data/models/money_objects/transactions/transactions.dart' as tx_collection;
import 'package:mockito/mockito.dart';
import 'package:mockito/annotations.dart';
import 'transaction_test.mocks.dart'; // Will be generated by build_runner
import 'package:money/data/models/money_objects/accounts/accounts.dart'; // Ensured Accounts is imported
import 'package:money/data/models/money_objects/payees/payee.dart'; // For Payee class
import 'package:money/core/helpers/date_helper.dart'; // For dateToString

// Annotate to generate mocks for Data and Accounts - MOVED HERE
@GenerateMocks([Data, Accounts])

// --- Manual MockAccount can still be useful for creating test data ---
class MockAccount extends Account {
  MockAccount({required int id, String name = 'Mock Account', String currency = 'USD'}) : super() {
    this.fieldId.value = id;
    this.fieldName.value = name;
    this.fieldCurrency.value = currency;
    // Set other fields if necessary for specific tests
  }

  @override
  double getCurrencyRatio() {
    // Simplify for tests; assume USD or direct ratio if needed
    if (fieldCurrency.value == 'USD') return 1.0;
    if (fieldCurrency.value == 'EUR') return 1.2; // Example
    return 1.0;
  }
}

// Removed manual MockAccounts, Mockito will generate MockAccounts
// class MockAccounts extends Accounts {
//   final Map<int, Account> _accounts = {};
//
//   void addAccount(Account account) {
//     _accounts[account.uniqueId] = account;
//   }
//
//   @override
//   Account? get(final int id, {final bool autoAdd = false}) {
//     return _accounts[id];
//   }
//
//   @override
//   String getNameFromId(final int id) {
//     return _accounts[id]?.fieldName.value ?? 'Unknown Account';
//   }
// }

// Mock other Data sub-managers as needed (Payees, Categories, etc.)
// class MockPayees extends Payees { /* ... empty for now ... */ }
// class MockCategories extends Categories { /* ... empty for now ... */ }
// class MockAliases extends Aliases { /* ... empty for now ... */ }
// class MockCurrencies extends Currencies { /* ... empty for now ... */ }
// class MockInvestments extends Investments { /* ... empty for now ... */ }
// class MockTransactions extends tx_collection.Transactions { /* ... empty for now ... */ }

// Manual MockDataContainer and its initialize method are no longer needed with Mockito generated mocks.

void main() {
  late MockData mockData; // Generated by Mockito
  late MockAccounts mockDataAccounts; // Generated by Mockito

  setUp(() {
    mockData = MockData();
    mockDataAccounts = MockAccounts();

    // Stubbing: when mockData.accounts is called, return mockDataAccounts
    when(mockData.accounts).thenReturn(mockDataAccounts);

    // Set the test instance for the Data singleton
    Data.setTestInstance(mockData);
  });

  tearDown(() {
    // Reset the Data singleton to its production instance after each test
    Data.resetInstance();
  });

  group('Transaction Default Constructor', () {
    test('initializes correctly with default values', () {
      final date = DateTime(2023, 1, 1);
      final transaction = Transaction(date: date);

      expect(transaction.fieldAccountId.value, -1);
      expect(transaction.fieldDateTime.value, date);
      expect(transaction.fieldStatus.value, TransactionStatus.none);
      expect(transaction.fieldFlags.value, TransactionFlags.none.index);
      expect(transaction.fieldAmount.value.asDouble(), 0.0);
    });

    test('initializes correctly with specified values', () {
      final date = DateTime(2023, 1, 1);
      final transaction = Transaction(
        status: TransactionStatus.cleared,
        accountId: 10,
        date: date,
      );

      expect(transaction.fieldAccountId.value, 10);
      expect(transaction.fieldDateTime.value, date);
      expect(transaction.fieldStatus.value, TransactionStatus.cleared);
    });
  });

  group('Transaction.fromJSon', () {
    final mockAccount = MockAccount(id: 1, name: 'Test Bank Account', currency: 'USD');

    test('parses basic fields correctly and looks up account', () {
      // Arrange: Setup the mock Accounts to return mockAccount when get(1) is called
      when(mockDataAccounts.get(1)).thenReturn(mockAccount);

      // This is the ideal scenario IF we can make Transaction.fromJSon use our mockData instance.
      // For example, if Transaction.fromJSon took an optional Data dataInstance parameter:
      // final transaction = Transaction.fromJSon(json, 1000.0, dataInstance: mockData);
      // Or if Data.setTestInstance(mockData) was possible.
      // For this test to pass regarding `instanceOfAccount`, such a mechanism is assumed to be in place.
      // If Data.setTestInstance(mockData); was called in setUp, this test would work as intended.
      // Otherwise, the real Data().accounts.get() will be called.

      final date = DateTime(2023, 10, 15);
      final json = {
        'Id': 100,
        'Account': 1, // This ID will be used by mockDataAccounts.get()
        'Date': date.toIso8601String(),
        'Status': TransactionStatus.cleared.index,
        'Payee': 200,
        'OriginalPayee': 'Original Vendor',
        'Category': 300,
        'Memo': 'Test transaction memo',
        'Number': 'CHK123',
        'FITID': 'FITID_XYZ',
        'Flags': TransactionFlags.unaccepted.index,
        'Amount': 123.45,
        'SalesTax': 12.34,
        'TransferSplit': -1,
      };

      // Act
      // IMPORTANT: This test assumes that Transaction.fromJSon will somehow use the
      // `mockData.accounts` (which returns `mockDataAccounts`) that was set up.
      // This requires `Data.setTestInstance(mockData);` or similar in `setUp`.
      // If that's not done, `Data().accounts.get()` will use the real singleton.
      final transaction = Transaction.fromJSon(json, 1000.0);

      // Assert
      expect(transaction.uniqueId, 100);
      expect(transaction.fieldAccountId.value, 1); // Raw ID is stored

      // This assertion will only pass if the Data() singleton was successfully mocked/replaced
      // to use `mockDataAccounts`. Otherwise, `instanceOfAccount` might be null or a real object.
      expect(transaction.instanceOfAccount, same(mockAccount));

      expect(transaction.fieldDateTime.value?.toIso8601String(), date.toIso8601String());
      expect(transaction.fieldStatus.value, TransactionStatus.cleared);
      expect(transaction.fieldPayee.value, 200);
      expect(transaction.fieldOriginalPayee.value, 'Original Vendor');
      expect(transaction.fieldCategoryId.value, 300);
      expect(transaction.fieldMemo.value, 'Test transaction memo');
      expect(transaction.fieldNumber.value, 'CHK123');
      expect(transaction.fieldFitid.value, 'FITID_XYZ');
      expect(transaction.fieldFlags.value, TransactionFlags.unaccepted.index);
      expect(transaction.fieldAmount.value.asDouble(), 123.45);
      expect(transaction.fieldSalesTax.value.asDouble(), 12.34);
      expect(transaction.fieldTransferSplit.value, -1);
      expect(transaction.balance, 1000.0);
    });

    test('handles missing optional fields with defaults', () {
      // Arrange: Stub for account lookup for Account ID 2
      when(mockDataAccounts.get(2)).thenReturn(null); // Or a different MockAccount if needed

      final date = DateTime(2023, 11, 1);
      final json = {
        'Id': 101,
        'Account': 2,
        'Date': date.toIso8601String(),
        'Amount': 50.0,
        // Status, Payee, Category, Memo, etc., are missing
      };
      final transaction = Transaction.fromJSon(json, 200.0);

      expect(transaction.uniqueId, 101);
      expect(transaction.fieldAccountId.value, 2);
      expect(transaction.fieldDateTime.value?.toIso8601String(), date.toIso8601String());
      expect(transaction.fieldAmount.value.asDouble(), 50.0);
      expect(transaction.balance, 200.0);

      // Check defaults for missing fields (as per MyJson getX behavior or class defaults)
      expect(transaction.fieldStatus.value, TransactionStatus.none); // Default for int 0
      expect(transaction.fieldPayee.value, -1); // Default for getInt
      expect(transaction.fieldOriginalPayee.value, ''); // Default for getString
      expect(transaction.fieldCategoryId.value, -1); // Default for getInt
      expect(transaction.fieldMemo.value, ''); // Default for getString
      expect(transaction.fieldNumber.value, '');
      expect(transaction.fieldFitid.value, '');
      expect(transaction.fieldFlags.value, 0); // Default for getInt
      expect(transaction.fieldSalesTax.value.asDouble(), 0.0);
      expect(transaction.fieldTransferSplit.value, -1);
      expect(transaction.fieldReconciledDate.value, isNull);
      expect(transaction.fieldBudgetBalanceDate.value, isNull);
      expect(transaction.fieldMergeDate.value, isNull);
    });
  });

  group('Transaction Getters', () {
    final mockAccount = MockAccount(id: 1, name: 'Test Bank Account', currency: 'EUR');
    final mockPayee = Payee()..fieldId.value = 20 ..fieldName.value = 'Test Payee';
    // Note: Mocking Categories and Payees on MockData would be needed if not using real Data()
    // For these simple getters, we can often construct the Transaction such that these are pre-set
    // or the Data().xxx.getNameFromId calls are stubbed.

    setUp(() {
      // Ensure Data().accounts.get(1) returns our mockAccount for these tests
      // This assumes Data.setTestInstance(mockData) is active from the main setUp
      when(mockDataAccounts.get(1)).thenReturn(mockAccount);

      // We'll need to mock Data().payees.getNameFromId and Data().categories.getNameFromId
      // This requires a MockPayees and MockCategories instance on mockData.
      // Let's assume mockData.payees and mockData.categories are also Mockito mocks.
      // For simplicity, if Mockito generated MockPayees and MockCategories:
      // when(mockData.payees).thenReturn(MockPayees()); // Or a specific instance
      // when(mockData.categories).thenReturn(MockCategories());
      // Then stub their methods:
      // when(mockData.payees.getNameFromId(20)).thenReturn('Test Payee');
      // when(mockData.categories.getNameFromId(30)).thenReturn('Test Category');
      // This setup can become complex if not managed in a shared way.
      // For now, we'll test a simpler case where this might not be strictly needed
      // or rely on the real Data() for these if mocks are not fully in place for sub-managers.
      // The refactored Data.setTestInstance makes this more robust.
    });

    test('accountName getter', () {
      final transaction = Transaction(accountId: 1, date: DateTime.now());
      // instanceOfAccount should be set by its getter using the mocked Data().accounts.get(1)
      expect(transaction.accountName, 'Test Bank Account');

      when(mockDataAccounts.get(2)).thenReturn(null);
      final transactionNoAccount = Transaction(accountId: 2, date: DateTime.now());
      expect(transactionNoAccount.accountName, '<Account???>');
    });

    test('currency getter', () {
      final transaction = Transaction(accountId: 1, date: DateTime.now());
      // instanceOfAccount is mockAccount which has 'EUR'
      expect(transaction.currency, 'EUR');

      // Test with an account that has no currency (should default)
      final mockAccountNoCurrency = MockAccount(id: 3, name: 'No Currency Account');
      mockAccountNoCurrency.fieldCurrency.value = ''; // Set empty currency
      when(mockDataAccounts.get(3)).thenReturn(mockAccountNoCurrency);
      final transactionNoCurrency = Transaction(accountId: 3, date: DateTime.now());
      expect(transactionNoCurrency.currency, Constants.defaultCurrency);

      // Test with no account instance (should default)
      when(mockDataAccounts.get(4)).thenReturn(null);
      final transactionNoAccount = Transaction(accountId: 4, date: DateTime.now());
      expect(transactionNoAccount.currency, Constants.defaultCurrency);
    });

    test('dateTimeAsString getter', () {
      final date = DateTime(2023, 5, 20, 15, 30);
      final transaction = Transaction(date: date);
      expect(transaction.dateTimeAsString, dateToString(date));
    });

    // payeeName and categoryName require more involved mocking of Data().payees and Data().categories
    // These will be tackled after confirming the basic mocking setup for Data().accounts works.
    // For now, this covers the simpler getters.
  });
}

// Minimal MyJson mock for testing (can be shared in a test_helper.dart)
extension TestJsonExtensions on Map<String, dynamic> {
  String getString(String key, [String defaultValue = '']) {
    return this[key] as String? ?? defaultValue;
  }

  int getInt(String key, [int defaultValue = 0]) {
    final value = this[key];
    if (value is int) return value;
    if (value is double) return value.toInt(); // Allow double to int conversion if applicable
    return defaultValue;
  }

  double getDouble(String key, [double defaultValue = 0.0]) {
    final value = this[key];
    if (value is double) return value;
    if (value is int) return value.toDouble();
    return defaultValue;
  }

  DateTime? getDate(String key) {
    final value = this[key];
    if (value is String) {
      return DateTime.tryParse(value);
    }
    return null;
  }
}
